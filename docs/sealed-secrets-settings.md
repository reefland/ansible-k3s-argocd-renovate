# Sealed Secrets Settings & Important Notes

[Back to README.md](../README.md)

Bitnami Labs [Sealed Secrets](https://github.com/bitnami-labs/sealed-secrets) are designed to allow for storage of sensitive information, such as passwords, keys, certificates, OAuth tokens, and SSH keys encrypted in secrets in a way that is considered safe for public github repositories.  

_Without Sealed Secrets the default Kubernetes secret is only base64 encoded which anyone can decode and completely not safe for public git repositories._

## Important Notes

* Sealed Secrets are completely transparent to your applications and they require zero modifications to use sealed secrets.
* By default sealed secrets are specific to the namespace it is generated for and cannot be used outside this namespace (this can be changed at creation time using the `--scope` argument)
* Sealed Secrets is not a set and forget technology.  You should read the documentation and understand the key rotation frequency (~30 days) and process
* You should be able to convert existing secret YAML files with `kubeseal` into Sealed Secrets which are considered safe to check into git public repositories (private repository is still recommended)
* This Ansible role will install the version matched `kubeseal` CLI tool for creation of sealed secrets
* Existing Secrets created by this Ansible role can be converted to Sealed Secrets at a later date if you do not wish to use Sealed Secrets as part of the initial installation.

### How This Ansible Role Handles Sealed Secrets

* When Sealed Secrets is not enabled:
  * Any secrets created or processed by this Ansible role will NOT be persistent to the git repository
  * The YAML files are deleted from disk after being processed and before git changes are determined and committed to repository
* When Sealed Secrets is enabled:
  * Any new secrets created by this role will be converted to Sealed Secret and that is applied and retained within the repository; the original secret is deleted and not committed to repository
  * Any existing secrets (unsealed) originally created by this role upon being processed again will be annotated to assign management to the Sealed Secrets controller
  * Then the secret as stored within Ansible (not as deployed in cluster) will be regenerated and converted to a Sealed Secret
  * The converted Sealed Secret will be applied to cluster which overwrites the existing secret deployed
  * This may reset passwords back to default to reset configurations back to default
  * The Sealed Secret encrypted YAML file will be committed to the git repository and managed by ArgoCD
    * The raw YAML files will be under `/workloads/secrets` and can be managed within Argo-CD via the `app-secrets` Argo-CD application:

  ![ArgoCD Application Container for applied Sealed Secrets](../images/argocd_app-secrets_sealed.png)

---

## Review `defaults/main.yml` for Sealed Secrets Settings

The Sealed Secrets Settings are in variable namespace `install.sealed_secrets`.

* Enable or disable installation of Sealed Secrets. Disabled will prevent any secrets generated by this role from being committed to git repository.

  ```yaml
  install:
    sealed_secrets:
      enabled: true
  ```

* Pin which version of Sealed Secrets to install.  This is the Helm Chart version, not the application version.
  * This is for initial installation only. Do not update this value to attempt to push an application upgrade.

  ```yaml
      # Select release to use: https://artifacthub.io/packages/helm/bitnami-labs/sealed-secrets
      install_version: "{{sealed_secret_install_version|default('v2.3.0')}}"
  ```

* Define the namespace to install Sealed Secrets into.

  ```yaml
      namespace: "kube-system"
  ```

* Determine if existing secrets (unsealed) should be replaced by Sealed Secrets.
  * If you use this Ansible Role to create and operate the kubernetes cluster without Sealed Secrets enabled, and then enable Sealed Secrets at a later point and attempt to re-run role tasks again you may see some failures when the task(s) process secrets already deployed
  * You will see a failure message such as:

  ```error
  Resource already exists and is not managed by Sealed Secret
  ```

  * You will have to either delete the existing secret within the cluster to allow a new secret to be created by the role task and converted to Sealed Secret OR enable the option below to allow the existing secret to be annotated for Sealed Secret management
  * This will allow the secret to be replaced by a Sealed Secret without needing manual deletion
  * Either way the contents of the original secret will be lost and the regenerated sealed secret will be whatever the default is by the role task.
    * However - once the initial conversion to Sealed Secrets is completed, this Ansbile role will not overwrite your existing sealed secrets within the repository. It will skip past existing sealed secrets it will only add new ones when required

  ```yaml
      # If a non-Sealed Secret (unsealed secret) already exists, by default it can NOT be replaced
      # by Sealed Secret version as it will fail with "Resource already exists and is not managed
      # by Sealed Secret" message. if replace_unsealed_secrets is "true" then the existing secret
      # will be annotated as managed by Sealed Secrets which will allow the non-Seale dSecret to be
      # replaced.
      replace_unsealed_secrets: true
  ```

---

## Review `vars/main.yml` for Sealed Secrets Defaults

The Sealed Secrets Settings are in variable namespace `sealed_secrets`.

* Default Sealed Secret controller name:

  This does not change the name to be using during installation.  This just lets Ansible know what the default controller name is.  This value will be used for all `kubeseal` commands and for the `kubeseal` alias with default controller name.

  ```yaml
  sealed_secrets:
    # This defines the default name used in Helm Chart, does not overwrite or change name to be used
    controller_name: "sealed-secrets"
  ```

* Default Scope for Sealed Secrets:
  The default scope for sealed secrets is `strict` but you can change the default to a little more open and less restrictive if you have a need for it.

  * `strict` (default): Sealed Secret uses secret name and the namespace. You can’t change the name or the namespaces of your SealedSecret once you've created it (it will not be decryptable)
  * `namespace-wide`: This scope allows you to freely rename the SealedSecret within the namespace for which you’ve sealed the Secret
  * `cluster-wide`: This scope allows you to freely move the Secret to any namespace within the cluster and rename it as you wish

  ```yaml
    default_scope: "strict"
  ```

* Default Annotation to Assigned to Unsealed Secrets

  To allow the Sealed Secrets controller to replace an existing unsealed secrets the secret will need to have an annotation applied to it.  Without this annotation the controller will refuse to replace it.

  ```yaml
    # Annotation that can be applied to an existing unsealed secret to mark it managed by Sealed
    # Secrets to allow it to be overwritten by Sealed Secrets.
    replace_unsealed_secrets_annotation: "sealedsecrets.bitnami.com/managed=true"
  ```

---

## Using Sealed Secrets

### Converting a Secret into a Sealed Secret

Assuming you have an existing YAML file named `myapp-secret.yaml`, this can be converted into a Sealed Secret via:

```shell
kubeseal --controller-name sealed-secrets --scope strict --format=yaml < myapp-secret.yaml > myapp-secret-sealed.yaml
```

The file generated `myapp-secret-sealed.yaml` would be applied to the cluster via `kubectl` and can be stored within your git repository:

```shell
kubectl apply -f myapp-secret-sealed.yaml [-n namespace-value]
```

The original secret `myapp-secret.yaml` should be deleted or stored someplace else with a fake value for future reference when you need to regenerate the secret.  The actual file with a real value should never be stored within your git repository.

---

## Troubleshooting Sealed Secrets

### Reusing Sealed Secrets from another Cluster

Sealed Secrets are specific to the cluster they were generated in.  Within the cluster resides the master signing key that was generated upon installation. Without that key trying to apply a sealed secret in a different cluster will not work, you will see a failure in the Sealed Secrets Controller log files:

```error
Sealed Secret failed for /home/kube/argocd/init_git_repo/workloads/secrets/argocd_admin_secret-sealed.yaml

Reason: no key could decrypt secret (admin.password, admin.passwordMtime, server.secretkey)
```

* Without the original master signing key you can not decrypt this sealed secret.  You will have to delete this secret and generate a new sealed secret, which will use this clusters signing key.

### Kubeseal reports Sealed Secrets Controller Not Found

The default sealed secrets controller name used by `kubeseal` is different than the default name used by Sealed Secrets installation.  This is expected:

```shell
$ kubeseal

error: cannot get sealed secret service: services "sealed-secrets-controller" not found
```

An alternate controller name can be supplied with argument `--controller-name sealed-secrets`. As this can be annoying to remember, this Ansible role will automatically create an alias for you that applies this argument:

```text
alias kubeseal='kubeseal --controller-name sealed-secrets'
```

---

### Monitor Sealed Secrets Controller Logs

The Sealed Secret controller can provide additional troubleshooting information when having issues with secrets:

```shell
kubectl logs pods/sealed-secrets-77c69dff5c-tb2mq -n kube-system
```

* Adjust the pod name to match whatever your instance shows.

[Back to README.md](../README.md)
